global:
  # The main enabled/disabled setting. If true, servers,
  # clients, Consul DNS and the Consul UI will be enabled. Each component can override
  # this default via its component-specific "enabled" config. If false, no components
  # will be installed by default and per-component opt-in is required, such as by
  # setting `server.enabled` to true.
  enabled: true

  # The default log level to apply to all components which do not otherwise override this setting.
  # It is recommended to generally not set this below "info" unless actively debugging due to logging verbosity.
  # One of "debug", "info", "warn", or "error".
  # @type: string
  logLevel: "info"

  # Enable all component logs to be output in JSON format.
  # @type: boolean
  logJSON: false

  # Set the prefix used for all resources in the Helm chart. If not set,
  # the prefix will be `<helm release name>-consul`.
  # @type: string
  name: null

  # The domain Consul will answer DNS queries for
  # (Refer to [`-domain`](https://developer.hashicorp.com/consul/docs/agent/config/cli-flags#_domain)) and the domain services synced from
  # Consul into Kubernetes will have, e.g. `service-name.service.consul`.
  domain: consul

  # Configures the Cluster Peering feature. Requires Consul v1.14+ and Consul-K8s v1.0.0+.
  peering:
    enabled: false

  image: hashicorp/consul:1.15.4

  # The name (and tag) of the consul-k8s-control-plane Docker
  # image that is used for functionality such as catalog sync.
  # This can be overridden per component.
  # @default: hashicorp/consul-k8s-control-plane:<latest version>
  imageK8S: hashicorp/consul-k8s-control-plane:1.1.3

  # The name of the datacenter that the agents should
  # register as. This can't be changed once the Consul cluster is up and running
  # since Consul doesn't support an automatic way to change this value currently:
  # https://github.com/hashicorp/consul/issues/1858.
  datacenter: ndh

  enablePodSecurityPolicies: false

  # secretsBackend is used to configure Vault as the secrets backend for the Consul on Kubernetes installation.
  # The Vault cluster needs to have the Kubernetes Auth Method, KV2 and PKI secrets engines enabled
  # and have necessary secrets, policies and roles created prior to installing Consul.
  # Refer to [Vault as the Secrets Backend](https://developer.hashicorp.com/consul/docs/k8s/deployment-configurations/vault)
  # documentation for full instructions.
  #
  # The Vault cluster _must_ not have the Consul cluster installed by this Helm chart as its storage backend
  # as that would cause a circular dependency.
  # Vault can have Consul as its storage backend as long as that Consul cluster is not running on this Kubernetes cluster
  # and is being managed separately from this Helm installation.
  #
  # Note: When using Vault KV2 secrets engines the "data" field is implicitly required for Vault API calls,
  # secretName should be in the form of  "vault-kv2-mount-path/data/secret-name".
  # secretKey should be in the form of "key".
  secretsBackend:
    vault:
      # Enabling the Vault secrets backend will replace Kubernetes secrets with referenced Vault secrets.
      enabled: false

      # The Vault role for the Consul server.
      # The role must be connected to the Consul server's service account.
      # The role must also have a policy with read capabilities for the following secrets:
      # - gossip encryption key defined by the `global.gossipEncryption.secretName` value
      # - certificate issue path defined by the `server.serverCert.secretName` value
      # - CA certificate defined by the `global.tls.caCert.secretName` value
      # - replication token defined by the `global.acls.replicationToken.secretName` value if `global.federation.enabled` is `true`
      # To discover the service account name of the Consul server, run
      # ```shell-session
      # $ helm template --show-only templates/server-serviceaccount.yaml <release-name> hashicorp/consul
      # ```
      # and check the name of `metadata.name`.
      consulServerRole: ""

      # The Vault role for the Consul client.
      # The role must be connected to the Consul client's service account.
      # The role must also have a policy with read capabilities for the gossip encryption
      # key defined by the `global.gossipEncryption.secretName` value.
      # To discover the service account name of the Consul client, run
      # ```shell-session
      # $ helm template --show-only templates/client-serviceaccount.yaml <release-name> hashicorp/consul
      # ```
      # and check the name of `metadata.name`.
      consulClientRole: ""

      # A Vault role for the Consul `server-acl-init` job, which manages setting ACLs so that clients and components can obtain ACL tokens.
      # The role must be connected to the `server-acl-init` job's service account.
      # The role must also have a policy with read and write capabilities for the bootstrap, replication or partition tokens
      # To discover the service account name of the `server-acl-init` job, run
      # ```shell-session
      # $ helm template --show-only templates/server-acl-init-serviceaccount.yaml \
      #   --set global.acls.manageSystemACLs=true <release-name> hashicorp/consul
      # ```
      # and check the name of `metadata.name`.
      manageSystemACLsRole: ""

      # [Enterprise Only] A Vault role that allows the Consul `partition-init` job to read a Vault secret for the partition ACL token.
      #  The `partition-init` job bootstraps Admin Partitions on Consul servers.
      # .
      # This role must be bound the `partition-init` job's service account.
      # To discover the service account name of the `partition-init` job, run with Helm values for the client cluster:
      # ```shell-session
      # $ helm template --show-only templates/partition-init-serviceaccount.yaml -f client-cluster-values.yaml <release-name> hashicorp/consul
      # ```
      # and check the name of `metadata.name`.
      adminPartitionsRole: ""

      # The Vault role to read Consul connect-injector webhook's CA
      # and issue a certificate and private key.
      # A Vault policy must be created which grants issue capabilities to
      # `global.secretsBackend.vault.connectInject.tlsCert.secretName`.
      connectInjectRole: ""

      # The Vault role for all Consul components to read the Consul's server's CA Certificate (unauthenticated).
      # The role should be connected to the service accounts of all Consul components, or alternatively `*` since it
      # will be used only against the `pki/cert/ca` endpoint which is unauthenticated. A policy must be created which grants
      # read capabilities to `global.tls.caCert.secretName`, which is usually `pki/cert/ca`.
      consulCARole: ""

      # This value defines additional annotations for
      # Vault agent on any pods where it'll be running.
      # This should be formatted as a multi-line string.
      #
      # ```yaml
      # annotations: |
      #   "sample/annotation1": "foo"
      #   "sample/annotation2": "bar"
      # ```
      #
      # @type: string
      agentAnnotations: null

      # Configuration for Vault server CA certificate. This certificate will be mounted
      # to any pod where Vault agent needs to run.
      ca:
        # The name of the Kubernetes or Vault secret that holds the Vault CA certificate.
        # A Kubernetes secret must be in the same namespace that Consul is installed into.
        secretName: ""
        # The key within the Kubernetes or Vault secret that holds the Vault CA certificate.
        secretKey: ""

      # Configuration for the Vault Connect CA provider.
      # The provider will be configured to use the Vault Kubernetes auth method
      # and therefore requires the role provided by `global.secretsBackend.vault.consulServerRole`
      # to have permissions to the root and intermediate PKI paths.
      # Please refer to [Vault ACL policies](https://developer.hashicorp.com/consul/docs/connect/ca/vault#vault-acl-policies)
      # documentation for information on how to configure the Vault policies.
      connectCA:
        # The address of the Vault server.
        address: ""

        # The mount path of the Kubernetes auth method in Vault.
        authMethodPath: "kubernetes"

        # The path to a PKI secrets engine for the root certificate.
        # For more details, please refer to [Vault Connect CA configuration](https://developer.hashicorp.com/consul/docs/connect/ca/vault#rootpkipath).
        rootPKIPath: ""

        # The path to a PKI secrets engine for the generated intermediate certificate.
        # For more details, please refer to [Vault Connect CA configuration](https://developer.hashicorp.com/consul/docs/connect/ca/vault#intermediatepkipath).
        intermediatePKIPath: ""

        # Additional Connect CA configuration in JSON format.
        # Please refer to [Vault Connect CA configuration](https://developer.hashicorp.com/consul/docs/connect/ca/vault#configuration)
        # for all configuration options available for that provider.
        #
        # Example:
        #
        # ```yaml
        # additionalConfig: |
        #   {
        #     "connect": [{
        #       "ca_config": [{
        #            "namespace": "my-vault-ns",
        #            "leaf_cert_ttl": "36h"
        #         }]
        #     }]
        #   }
        # ```
        additionalConfig: |
          {}

      connectInject:
        # Configuration to the Vault Secret that Kubernetes uses on
        # Kubernetes pod creation, deletion, and update, to get CA certificates
        # used issued from vault to send webhooks to the ConnectInject.
        caCert:
          # The Vault secret path that contains the CA certificate for
          # Connect Inject webhooks.
          # @type: string
          secretName: null

        # Configuration to the Vault Secret that Kubernetes uses on
        # Kubernetes pod creation, deletion, and update, to get TLS certificates
        # used issued from vault to send webhooks to the ConnectInject.
        tlsCert:
          # The Vault secret path that issues TLS certificates for connect
          # inject webhooks.
          # @type: string
          secretName: null

  # Configures Consul's gossip encryption key.
  # (Refer to [`-encrypt`](https://developer.hashicorp.com/consul/docs/agent/config/cli-flags#_encrypt)).
  # By default, gossip encryption is not enabled. The gossip encryption key may be set automatically or manually.
  # The recommended method is to automatically generate the key.
  # To automatically generate and set a gossip encryption key, set autoGenerate to true.
  # Values for secretName and secretKey should not be set if autoGenerate is true.
  # To manually generate a gossip encryption key, set secretName and secretKey and use Consul to generate
  # a key, saving this as a Kubernetes secret or Vault secret path and key.
  # If `global.secretsBackend.vault.enabled=true`, be sure to add the "data" component of the secretName path as required by
  # the Vault KV-2 secrets engine [refer to example].
  #
  # ```shell-session
  # $ kubectl create secret generic consul-gossip-encryption-key --from-literal=key=$(consul keygen)
  # ```
  #
  # Vault CLI Example:
  # ```shell-session
  # $ vault kv put consul/secrets/gossip key=$(consul keygen)
  # ```
  # `gossipEncryption.secretName="consul/data/secrets/gossip"`
  # `gossipEncryption.secretKey="key"`

  gossipEncryption:
    # Automatically generate a gossip encryption key and save it to a Kubernetes or Vault secret.
    autoGenerate: false
    # The name of the Kubernetes secret or Vault secret path that holds the gossip
    # encryption key. A Kubernetes secret must be in the same namespace that Consul is installed into.
    secretName: ""
    # The key within the Kubernetes secret or Vault secret key that holds the gossip
    # encryption key.
    secretKey: ""

  # A list of addresses of upstream DNS servers that are used to recursively resolve DNS queries.
  # These values are given as `-recursor` flags to Consul servers and clients.
  # Refer to [`-recursor`](https://developer.hashicorp.com/consul/docs/agent/config/cli-flags#_recursor) for more details.
  # If this is an empty array (the default), then Consul DNS will only resolve queries for the Consul top level domain (by default `.consul`).
  # @type: array<string>
  recursors: []

  # Enables [TLS](https://developer.hashicorp.com/consul/tutorials/security/tls-encryption-secure)
  # across the cluster to verify authenticity of the Consul servers and clients.
  # Requires Consul v1.4.1+.
  tls:
    # If true, the Helm chart will enable TLS for Consul
    # servers and clients and all consul-k8s-control-plane components, as well as generate certificate
    # authority (optional) and server and client certificates.
    # This setting is required for [Cluster Peering](https://developer.hashicorp.com/consul/docs/connect/cluster-peering/k8s).
    enabled: false

    # If true, turns on the auto-encrypt feature on clients and servers.
    # It also switches consul-k8s-control-plane components to retrieve the CA from the servers
    # via the API. Requires Consul 1.7.1+.
    enableAutoEncrypt: false

    # A list of additional DNS names to set as Subject Alternative Names (SANs)
    # in the server certificate. This is useful when you need to access the
    # Consul server(s) externally, for example, if you're using the UI.
    # @type: array<string>
    serverAdditionalDNSSANs: []

    # A list of additional IP addresses to set as Subject Alternative Names (SANs)
    # in the server certificate. This is useful when you need to access the
    # Consul server(s) externally, for example, if you're using the UI.
    # @type: array<string>
    serverAdditionalIPSANs: []

    # If true, `verify_outgoing`, `verify_server_hostname`,
    # and `verify_incoming` for internal RPC communication will be set to `true` for Consul servers and clients.
    # Set this to false to incrementally roll out TLS on an existing Consul cluster.
    # Please refer to [TLS on existing clusters](https://developer.hashicorp.com/consul/docs/k8s/operations/tls-on-existing-cluster)
    # for more details.
    verify: true

    # If true, the Helm chart will configure Consul to disable the HTTP port on
    # both clients and servers and to only accept HTTPS connections.
    httpsOnly: true

    # A secret containing the certificate of the CA to use for TLS communication within the Consul cluster.
    # If you have generated the CA yourself with the consul CLI, you could use the following command to create the secret
    # in Kubernetes:
    #
    # ```shell-session
    # $ kubectl create secret generic consul-ca-cert \
    #     --from-file='tls.crt=./consul-agent-ca.pem'
    # ```
    # If you are using Vault as a secrets backend with TLS, `caCert.secretName` must be provided and should reference
    # the CA path for your PKI secrets engine. This should be of the form `pki/cert/ca` where `pki` is the mount point of your PKI secrets engine.
    # A read policy must be created and associated with the CA cert path for `global.tls.caCert.secretName`.
    # This will be consumed by the `global.secretsBackend.vault.consulCARole` role by all Consul components.
    # When using Vault the secretKey is not used.
    caCert:
      # The name of the Kubernetes or Vault secret that holds the CA certificate.
      # @type: string
      secretName: null
      # The key within the Kubernetes or Vault secret that holds the CA certificate.
      # @type: string
      secretKey: null

    # A Kubernetes or Vault secret containing the private key of the CA to use for
    # TLS communication within the Consul cluster. If you have generated the CA yourself
    # with the consul CLI, you could use the following command to create the secret
    # in Kubernetes:
    #
    # ```shell-session
    # $ kubectl create secret generic consul-ca-key \
    #     --from-file='tls.key=./consul-agent-ca-key.pem'
    # ```
    #
    # Note that we need the CA key so that we can generate server and client certificates.
    # It is particularly important for the client certificates since they need to have host IPs
    # as Subject Alternative Names. If you are setting server certs yourself via `server.serverCert`
    # and you are not enabling clients (or clients are enabled with autoEncrypt) then you do not
    # need to provide the CA key.
    caKey:
      # The name of the Kubernetes or Vault secret that holds the CA key.
      # @type: string
      secretName: null
      # The key within the Kubernetes or Vault secret that holds the CA key.
      # @type: string
      secretKey: null

  # [Enterprise Only] `enableConsulNamespaces` indicates that you are running
  # Consul Enterprise v1.7+ with a valid Consul Enterprise license and would
  # like to make use of configuration beyond registering everything into
  # the `default` Consul namespace. Additional configuration
  # options are found in the `consulNamespaces` section of both the catalog sync
  # and connect injector.
  enableConsulNamespaces: false

  # Configure ACLs.
  acls:
    # If true, the Helm chart will automatically manage ACL tokens and policies
    # for all Consul and consul-k8s-control-plane components.
    # This requires Consul >= 1.4.
    manageSystemACLs: false

    # A Kubernetes or Vault secret containing the bootstrap token to use for creating policies and
    # tokens for all Consul and consul-k8s-control-plane components. If `secretName` and `secretKey`
    # are unset, a default secret name and secret key are used. If the secret is populated, then
    # we will skip ACL bootstrapping of the servers and will only initialize ACLs for the Consul
    # clients and consul-k8s-control-plane system components.
    # If the secret is empty, then we will bootstrap ACLs on the Consul servers, and write the
    # bootstrap token to this secret. If ACLs are already bootstrapped on the servers, then the
    # secret must contain the bootstrap token.
    bootstrapToken:
      # The name of the Kubernetes or Vault secret that holds the bootstrap token.
      # If unset, this defaults to `{{ global.name }}-bootstrap-acl-token`.
      secretName: null
      # The key within the Kubernetes or Vault secret that holds the bootstrap token.
      # If unset, this defaults to `token`.
      secretKey: null

    # If true, an ACL token will be created that can be used in secondary
    # datacenters for replication. This should only be set to true in the
    # primary datacenter since the replication token must be created from that
    # datacenter.
    # In secondary datacenters, the secret needs to be imported from the primary
    # datacenter and referenced via `global.acls.replicationToken`.
    createReplicationToken: false

    # replicationToken references a secret containing the replication ACL token.
    # This token will be used by secondary datacenters to perform ACL replication
    # and create ACL tokens and policies.
    # This value is ignored if `bootstrapToken` is also set.
    replicationToken:
      # The name of the Kubernetes or Vault secret that holds the replication token.
      # @type: string
      secretName: null
      # The key within the Kubernetes or Vault secret that holds the replication token.
      # @type: string
      secretKey: null

    # The resource requests (CPU, memory, etc.) for the server-acl-init and server-acl-init-cleanup pods.
    # This should be a YAML map corresponding to a Kubernetes
    # [`ResourceRequirements``](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.27/#resourcerequirements-v1-core)
    # object.
    #
    # Example:
    #
    # ```yaml
    # resources:
    #   requests:
    #     memory: '200Mi'
    #     cpu: '100m'
    #   limits:
    #     memory: '200Mi'
    #     cpu: '100m'
    # ```
    #
    # @recurse: false
    # @type: map
    resources:
      requests:
        memory: "50Mi"
        cpu: "50m"
      limits:
        memory: "50Mi"
        cpu: "50m"

    # partitionToken references a Vault secret containing the ACL token to be used in non-default partitions.
    # This value should only be provided in the default partition and only when setting
    # the `global.secretsBackend.vault.enabled` value to true.
    # Consul will use the value of the secret stored in Vault to create an ACL token in Consul with the value of the
    # secret as the secretID for the token.
    # In non-default, partitions set this secret as the `bootstrapToken`.
    partitionToken:
      # The name of the Vault secret that holds the partition token.
      # @type: string
      secretName: null
      # The key within the Vault secret that holds the parition token.
      # @type: string
      secretKey: null

    # tolerations configures the taints and tolerations for the server-acl-init
    # and server-acl-init-cleanup jobs. This should be a multi-line string matching the
    # [Tolerations](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/) array in a Pod spec.
    tolerations: ""

    # This value defines [`nodeSelector`](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector)
    # labels for the server-acl-init and server-acl-init-cleanup jobs pod assignment, formatted as a multi-line string.
    #
    # Example:
    #
    # ```yaml
    # nodeSelector: |
    #   beta.kubernetes.io/arch: amd64
    # ```
    #
    # @type: string
    nodeSelector: null

  # Configure federation.
  federation:
    enabled: false

  # Configures metrics for Consul service mesh
  metrics:
    enabled: true

    enableAgentMetrics: true
    agentMetricsRetentionTime: 1m
    enableGatewayMetrics: false
    enableTelemetryCollector: false
  imageConsulDataplane: hashicorp/consul-dataplane:1.1.3

  # The time in seconds that the consul API client will wait for a response from
  # the API before cancelling the request.
  consulAPITimeout: 5s
  extraLabels: {}
  trustedCAs: []

server:
  enabled: true
  image: null
  replicas: 1

  # The number of servers that are expected to be running.
  # It defaults to server.replicas.
  # In most cases the default should be used, however if there are more
  # servers in this datacenter than server.replicas it might make sense
  # to override the default. This would be the case if two kube clusters
  # were joined into the same datacenter and each cluster ran a certain number
  # of servers.
  # @type: int
  bootstrapExpect: null

  # A secret containing a certificate & key for the server agents to use
  # for TLS communication within the Consul cluster. Cert needs to be provided with
  # additional DNS name SANs so that it will work within the Kubernetes cluster:
  #
  # Kubernetes Secrets backend:
  # ```bash
  # consul tls cert create -server -days=730 -domain=consul -ca=consul-agent-ca.pem \
  #     -key=consul-agent-ca-key.pem -dc={{datacenter}} \
  #     -additional-dnsname="{{fullname}}-server" \
  #     -additional-dnsname="*.{{fullname}}-server" \
  #     -additional-dnsname="*.{{fullname}}-server.{{namespace}}" \
  #     -additional-dnsname="*.{{fullname}}-server.{{namespace}}.svc" \
  #     -additional-dnsname="*.server.{{datacenter}}.{{domain}}" \
  #     -additional-dnsname="server.{{datacenter}}.{{domain}}"
  # ```
  #
  # If you have generated the server-cert yourself with the consul CLI, you could use the following command
  # to create the secret in Kubernetes:
  #
  # ```bash
  # kubectl create secret generic consul-server-cert \
  #     --from-file='tls.crt=./dc1-server-consul-0.pem'
  #     --from-file='tls.key=./dc1-server-consul-0-key.pem'
  # ```
  #
  # Vault Secrets backend:
  # If you are using Vault as a secrets backend, a Vault Policy must be created which allows `["create", "update"]`
  # capabilities on the PKI issuing endpoint, which is usually of the form `pki/issue/consul-server`.
  # Complete [this tutorial](https://developer.hashicorp.com/consul/tutorials/vault-secure/vault-pki-consul-secure-tls)
  # to learn how to generate a compatible certificate.
  # Note: when using TLS, both the `server.serverCert` and `global.tls.caCert` which points to the CA endpoint of this PKI engine
  # must be provided.
  serverCert:
    # The name of the Vault secret that holds the PEM encoded server certificate.
    # @type: string
    secretName: null

  # Exposes the servers' gossip and RPC ports as hostPorts. To enable a client
  # agent outside of the k8s cluster to join the datacenter, you would need to
  # enable `server.exposeGossipAndRPCPorts`, `client.exposeGossipPorts`, and
  # set `server.ports.serflan.port` to a port not being used on the host. Since
  # `client.exposeGossipPorts` uses the hostPort 8301,
  # `server.ports.serflan.port` must be set to something other than 8301.
  exposeGossipAndRPCPorts: false

  # Configures ports for the consul servers.
  ports:
    # Configures the LAN gossip port for the consul servers. If you choose to
    # enable `server.exposeGossipAndRPCPorts` and `client.exposeGossipPorts`,
    # that will configure the LAN gossip ports on the servers and clients to be
    # hostPorts, so if you are running clients and servers on the same node the
    # ports will conflict if they are both 8301. When you enable
    # `server.exposeGossipAndRPCPorts` and `client.exposeGossipPorts`, you must
    # change this from the default to an unused port on the host, e.g. 9301. By
    # default the LAN gossip port is 8301 and configured as a containerPort on
    # the consul server Pods.
    serflan:
      port: 8301

  # This defines the disk size for configuring the
  # servers' StatefulSet storage. For dynamically provisioned storage classes, this is the
  # desired size. For manually defined persistent volumes, this should be set to
  # the disk size of the attached volume.
  storage: 5Gi
  storageClass: null
  connect: false

  serviceAccount:
    # This value defines additional annotations for the server service account. This should be formatted as a multi-line
    # string.
    #
    # ```yaml
    # annotations: |
    #   "sample/annotation1": "foo"
    #   "sample/annotation2": "bar"
    # ```
    #
    # @type: string
    annotations: null

  resources:
    requests:
      memory: "200Mi"
      cpu: "100m"
    limits:
      memory: "200Mi"
      cpu: "100m"

  securityContext:
    runAsNonRoot: true
    runAsGroup: 1000
    runAsUser: 100
    fsGroup: 1000

  containerSecurityContext:
    server: null

  # This value is used to carefully
  # control a rolling update of Consul server agents. This value specifies the
  # [partition](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#partitions)
  # for performing a rolling update. Please read the linked Kubernetes
  # and [Upgrade Consul](https://developer.hashicorp.com/consul/docs/k8s/upgrade#upgrading-consul-servers)
  # documentation for more information.
  updatePartition: 0

  # This configures the [`PodDisruptionBudget`](https://kubernetes.io/docs/tasks/run-application/configure-pdb/)
  # for the server cluster.
  disruptionBudget:
    enabled: true
    maxUnavailable: null

  # A raw string of extra [JSON configuration](https://developer.hashicorp.com/consul/docs/agent/config/config-files) for Consul
  # servers. This will be saved as-is into a ConfigMap that is read by the Consul
  # server agents. This can be used to add additional configuration that
  # isn't directly exposed by the chart.
  #
  # Example:
  #
  # ```yaml
  # extraConfig: |
  #   {
  #     "log_level": "DEBUG"
  #   }
  # ```
  #
  # This can also be set using Helm's `--set` flag using the following syntax:
  #
  # ```shell-session
  # --set 'server.extraConfig="{"log_level": "DEBUG"}"'
  # ```
  extraConfig: |
    {}

  # A list of extra volumes to mount for server agents. This
  # is useful for bringing in extra data that can be referenced by other configurations
  # at a well known path, such as TLS certificates or Gossip encryption keys. The
  # value of this should be a list of objects.
  #
  # Example:
  #
  # ```yaml
  # extraVolumes:
  #   - type: secret
  #     name: consul-certs
  #     load: false
  # ```
  #
  # Each object supports the following keys:
  #
  # - `type` - Type of the volume, must be one of "configMap" or "secret". Case sensitive.
  #
  # - `name` - Name of the configMap or secret to be mounted. This also controls
  #   the path that it is mounted to. The volume will be mounted to `/consul/userconfig/<name>`.
  #
  # - `load` - If true, then the agent will be
  #   configured to automatically load HCL/JSON configuration files from this volume
  #   with `-config-dir`. This defaults to false.
  #
  # @type: array<map>
  extraVolumes: []

  # A list of sidecar containers.
  # Example:
  #
  # ```yaml
  # extraContainers:
  # - name: extra-container
  #   image: example-image:latest
  #   command:
  #    - ...
  # ```
  # @type: array<map>
  extraContainers: []

  affinity: |
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchLabels:
              app: {{ template "consul.name" . }}
              release: "{{ .Release.Name }}"
              component: server
          topologyKey: kubernetes.io/hostname

  tolerations: ""

  # Pod topology spread constraints for server pods.
  # This should be a multi-line YAML string matching the
  # [`topologySpreadConstraints`](https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/)
  # array in a Pod Spec.
  #
  # This requires K8S >= 1.18 (beta) or 1.19 (stable).
  #
  # Example:
  #
  # ```yaml
  # topologySpreadConstraints: |
  #   - maxSkew: 1
  #     topologyKey: topology.kubernetes.io/zone
  #     whenUnsatisfiable: DoNotSchedule
  #     labelSelector:
  #       matchLabels:
  #         app: {{ template "consul.name" . }}
  #         release: "{{ .Release.Name }}"
  #         component: server
  # ```
  topologySpreadConstraints: ""
  nodeSelector: null
  priorityClassName: ""
  extraLabels: null
  annotations: null

  # Configures a service to expose ports on the Consul servers over a Kubernetes Service.
  exposeService:
    enabled: false
  service:
    annotations: null
  extraEnvironmentVars: {}

# Configuration for Consul servers when the servers are running outside of Kubernetes.
# When running external servers, configuring these values is recommended
# if setting `global.tls.enableAutoEncrypt` to true
# or `global.acls.manageSystemACLs` to true.
externalServers:
  enabled: false

# Values that configure running a Consul client on Kubernetes nodes.
client:
  enabled: false

# Configuration for DNS configuration within the Kubernetes cluster.
# This creates a service that routes to all agents (client or server)
# for serving DNS requests. This DOES NOT automatically configure kube-dns
# today, so you must still manually configure a `stubDomain` with kube-dns
# for this to have any effect:
# https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#configure-stub-domain-and-upstream-dns-servers
dns:
  # @type: boolean
  enabled: "-"

  # If true, services using Consul Connect will use Consul DNS
  # for default DNS resolution. The DNS lookups fall back to the nameserver IPs
  # listed in /etc/resolv.conf if not found in Consul.
  # @type: boolean
  enableRedirection: "-"

  # Used to control the type of service created. For
  # example, setting this to "LoadBalancer" will create an external load
  # balancer (for supported K8S installations)
  type: ClusterIP

  # Set a predefined cluster IP for the DNS service.
  # Useful if you need to reference the DNS service's IP
  # address in CoreDNS config.
  # @type: string
  clusterIP: null

  # Extra annotations to attach to the dns service
  # This should be a multi-line string of
  # annotations to apply to the dns Service
  # @type: string
  annotations: null

  # Additional ServiceSpec values
  # This should be a multi-line string mapping directly to a Kubernetes
  # ServiceSpec object.
  # @type: string
  additionalSpec: null

# Values that configure the Consul UI.
ui:
  enabled: "true"

  # Configure the service for the Consul UI.
  service:
    enabled: true
    type: null
    port:
      http: 80
      https: 443
    annotations: null
    additionalSpec: null
  ingress:
    enabled: false

  # Configurations for displaying metrics in the UI.
  metrics:
    enabled: false
  dashboardURLTemplates:
    service: ""

# Configure the catalog sync process to sync K8S with Consul
# services. This can run bidirectional (default) or unidirectionally (Consul
# to K8S or K8S to Consul only).
#
# This process assumes that a Consul agent is available on the host IP.
# This is done automatically if clients are enabled. If clients are not
# enabled then set the node selection so that it chooses a node with a
# Consul agent.
syncCatalog:
  # True if you want to enable the catalog sync. Set to "-" to inherit from
  # global.enabled.
  enabled: false

  # The name of the Docker image (including any tag) for consul-k8s-control-plane
  # to run the sync program.
  # @type: string
  image: null

  # If true, all valid services in K8S are
  # synced by default. If false, the service must be [annotated](https://developer.hashicorp.com/consul/docs/k8s/service-sync#enable-and-disable-sync)
  # properly to sync.
  # In either case an annotation can override the default.
  default: true

  # Optional priorityClassName.
  priorityClassName: ""

  # If true, will sync Kubernetes services to Consul. This can be disabled to
  # have a one-way sync.
  toConsul: true

  # If true, will sync Consul services to Kubernetes. This can be disabled to
  # have a one-way sync.
  toK8S: true

  # Service prefix to prepend to services before registering
  # with Kubernetes. For example "consul-" will register all services
  # prepended with "consul-". (Consul -> Kubernetes sync)
  # @type: string
  k8sPrefix: null

  # List of k8s namespaces to sync the k8s services from.
  # If a k8s namespace is not included in this list or is listed in `k8sDenyNamespaces`,
  # services in that k8s namespace will not be synced even if they are explicitly
  # annotated. Use `["*"]` to automatically allow all k8s namespaces.
  #
  # For example, `["namespace1", "namespace2"]` will only allow services in the k8s
  # namespaces `namespace1` and `namespace2` to be synced and registered
  # with Consul. All other k8s namespaces will be ignored.
  #
  # To deny all namespaces, set this to `[]`.
  #
  # Note: `k8sDenyNamespaces` takes precedence over values defined here.
  # @type: array<string>
  k8sAllowNamespaces: ["*"]

  # List of k8s namespaces that should not have their
  # services synced. This list takes precedence over `k8sAllowNamespaces`.
  # `*` is not supported because then nothing would be allowed to sync.
  #
  # For example, if `k8sAllowNamespaces` is `["*"]` and `k8sDenyNamespaces` is
  # `["namespace1", "namespace2"]`, then all k8s namespaces besides `namespace1`
  # and `namespace2` will be synced.
  # @type: array<string>
  k8sDenyNamespaces: ["kube-system", "kube-public"]

  # [DEPRECATED] Use k8sAllowNamespaces and k8sDenyNamespaces instead. For
  # backwards compatibility, if both this and the allow/deny lists are set,
  # the allow/deny lists will be ignored.
  # k8sSourceNamespace is the Kubernetes namespace to watch for service
  # changes and sync to Consul. If this is not set then it will default
  # to all namespaces.
  # @type: string
  k8sSourceNamespace: null

  # [Enterprise Only] These settings manage the catalog sync's interaction with
  # Consul namespaces (requires consul-ent v1.7+).
  # Also, `global.enableConsulNamespaces` must be true.
  consulNamespaces:
    # Name of the Consul namespace to register all
    # k8s services into. If the Consul namespace does not already exist,
    # it will be created. This will be ignored if `mirroringK8S` is true.
    consulDestinationNamespace: "default"

    # If true, k8s services will be registered into a Consul namespace
    # of the same name as their k8s namespace, optionally prefixed if
    # `mirroringK8SPrefix` is set below. If the Consul namespace does not
    # already exist, it will be created. Turning this on overrides the
    # `consulDestinationNamespace` setting.
    # `addK8SNamespaceSuffix` may no longer be needed if enabling this option.
    # If mirroring is enabled, avoid creating any Consul resources in the following
    # Kubernetes namespaces, as Consul currently reserves these namespaces for
    # system use: "system", "universal", "operator", "root".
    mirroringK8S: true

    # If `mirroringK8S` is set to true, `mirroringK8SPrefix` allows each Consul namespace
    # to be given a prefix. For example, if `mirroringK8SPrefix` is set to "k8s-", a
    # service in the k8s `staging` namespace will be registered into the
    # `k8s-staging` Consul namespace.
    mirroringK8SPrefix: ""

  # Appends Kubernetes namespace suffix to
  # each service name synced to Consul, separated by a dash.
  # For example, for a service 'foo' in the default namespace,
  # the sync process will create a Consul service named 'foo-default'.
  # Set this flag to true to avoid registering services with the same name
  # but in different namespaces as instances for the same Consul service.
  # Namespace suffix is not added if 'annotationServiceName' is provided.
  addK8SNamespaceSuffix: true

  # Service prefix which prepends itself
  # to Kubernetes services registered within Consul
  # For example, "k8s-" will register all services prepended with "k8s-".
  # (Kubernetes -> Consul sync)
  # consulPrefix is ignored when 'annotationServiceName' is provided.
  # NOTE: Updating this property to a non-null value for an existing installation will result in deregistering
  # of existing services in Consul and registering them with a new name.
  # @type: string
  consulPrefix: null

  # Optional tag that is applied to all of the Kubernetes services
  # that are synced into Consul. If nothing is set, defaults to "k8s".
  # (Kubernetes -> Consul sync)
  # @type: string
  k8sTag: null

  # Defines the Consul synthetic node that all services
  # will be registered to.
  # NOTE: Changing the node name and upgrading the Helm chart will leave
  # all of the previously sync'd services registered with Consul and
  # register them again under the new Consul node name. The out-of-date
  # registrations will need to be explicitly removed.
  consulNodeName: "k8s-sync"

  # Syncs services of the ClusterIP type, which may
  # or may not be broadly accessible depending on your Kubernetes cluster.
  # Set this to false to skip syncing ClusterIP services.
  syncClusterIPServices: true

  ingress:
    # Syncs the hostname from a Kubernetes Ingress resource to service registrations
    # when a rule matched a service. Currently only supports host based routing and
    # not path based routing. The only supported path on an ingress rule is "/".
    # Set this to false to skip syncing Ingress services.
    #
    # Currently, port 80 is synced if there is not TLS entry for the hostname. Syncs the port
    # 443 if there is a TLS entry that matches the hostname.
    enabled: false
    # Requires syncIngress to be `true`. syncs the LoadBalancer IP from a Kubernetes Ingress
    # resource instead of the hostname to service registrations when a rule matched a service.
    loadBalancerIPs: false

  # Configures the type of syncing that happens for NodePort
  # services. The valid options are: ExternalOnly, InternalOnly, ExternalFirst.
  #
  # - ExternalOnly will only use a node's ExternalIP address for the sync
  # - InternalOnly use's the node's InternalIP address
  # - ExternalFirst will preferentially use the node's ExternalIP address, but
  #   if it doesn't exist, it will use the node's InternalIP address instead.
  nodePortSyncType: ExternalFirst

  # Refers to a Kubernetes secret that you have created that contains
  # an ACL token for your Consul cluster which allows the sync process the correct
  # permissions. This is only needed if ACLs are managed manually within the Consul cluster, i.e. `global.acls.manageSystemACLs` is `false`.
  aclSyncToken:
    # The name of the Kubernetes secret that holds the acl sync token.
    # @type: string
    secretName: null
    # The key within the Kubernetes secret that holds the acl sync token.
    # @type: string
    secretKey: null

  # This value defines [`nodeSelector`](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector)
  # labels for catalog sync pod assignment, formatted as a multi-line string.
  #
  # Example:
  #
  # ```yaml
  # nodeSelector: |
  #   beta.kubernetes.io/arch: amd64
  # ```
  #
  # @type: string
  nodeSelector: null

  # Affinity Settings
  # This should be a multi-line string matching the affinity object
  # @type: string
  affinity: null

  # Toleration Settings
  # This should be a multi-line string matching the Toleration array
  # in a PodSpec.
  # @type: string
  tolerations: null

  serviceAccount:
    # This value defines additional annotations for the mesh gateways' service account. This should be formatted as a
    # multi-line string.
    #
    # ```yaml
    # annotations: |
    #   "sample/annotation1": "foo"
    #   "sample/annotation2": "bar"
    # ```
    #
    # @type: string
    annotations: null

  # The resource settings for sync catalog pods.
  # @recurse: false
  # @type: map
  resources:
    requests:
      memory: "50Mi"
      cpu: "50m"
    limits:
      memory: "50Mi"
      cpu: "50m"

  # Override global log verbosity level. One of "debug", "info", "warn", or "error".
  # @type: string
  logLevel: ""

  # Override the default interval to perform syncing operations creating Consul services.
  # @type: string
  consulWriteInterval: null

  # Extra labels to attach to the sync catalog pods. This should be a YAML map.
  #
  # Example:
  #
  # ```yaml
  # extraLabels:
  #   labelKey: label-value
  #   anotherLabelKey: another-label-value
  # ```
  #
  # @type: map
  extraLabels: null

  # This value defines additional annotations for
  # the catalog sync pods. This should be formatted as a multi-line string.
  #
  # ```yaml
  # annotations: |
  #   "sample/annotation1": "foo"
  #   "sample/annotation2": "bar"
  # ```
  #
  # @type: string
  annotations: null

# Configures the automatic Connect sidecar injector.
connectInject:
  enabled: false

meshGateway:
  enabled: false

ingressGateways:
  enabled: false

terminatingGateways:
  enabled: false

# Configuration settings for the Consul API Gateway integration
apiGateway:
  enabled: false

# Configuration settings for the webhook-cert-manager
# `webhook-cert-manager` ensures that cert bundles are up to date for the mutating webhook.
webhookCertManager:
  tolerations: null

  # This value defines [`nodeSelector`](https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector)
  # labels for the webhook-cert-manager pod assignment, formatted as a multi-line string.
  #
  # Example:
  #
  # ```yaml
  # nodeSelector: |
  #   beta.kubernetes.io/arch: amd64
  # ```
  #
  # @type: string
  nodeSelector: null

prometheus:
  enabled: false

# Control whether a test Pod manifest is generated when running helm template.
# When using helm install, the test Pod is not submitted to the cluster so this
# is only useful when running helm template.
tests:
  enabled: true

telemetryCollector:
  enabled: false
